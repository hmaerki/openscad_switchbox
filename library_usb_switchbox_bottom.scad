// Generated by SolidPython 1.1.1 on 2021-05-17 21:24:03
$fn = 100;


difference() {
	union() {
		difference() {
			linear_extrude(height = 16.5000000000) {
				offset(r = 6.0000000000) {
					square(center = true, size = [108.0000000000, 54.0000000000]);
				}
			}
			translate(v = [0, 0, 1.6000000000]) {
				linear_extrude(height = 16.5100000000) {
					difference() {
						offset(r = 4.4000000000) {
							square(center = true, size = [108.0000000000, 54.0000000000]);
						}
						union() {
							translate(v = [-60.0000000000, -33.0000000000, 0]) {
								difference() {
									translate(v = [-1.5000000000, -1.5000000000, 0]) {
										offset(r = 3.0000000000) {
											square(size = [7.0000000000, 7.0000000000]);
										}
									}
									translate(v = [4.0000000000, 4.0000000000, 0]) {
										circle(r = 0.7500000000);
									}
								}
							}
							mirror(v = [1, 0, 0]) {
								translate(v = [-60.0000000000, -33.0000000000, 0]) {
									difference() {
										translate(v = [-1.5000000000, -1.5000000000, 0]) {
											offset(r = 3.0000000000) {
												square(size = [7.0000000000, 7.0000000000]);
											}
										}
										translate(v = [4.0000000000, 4.0000000000, 0]) {
											circle(r = 0.7500000000);
										}
									}
								}
							}
							mirror(v = [0, 1, 0]) {
								union() {
									translate(v = [-60.0000000000, -33.0000000000, 0]) {
										difference() {
											translate(v = [-1.5000000000, -1.5000000000, 0]) {
												offset(r = 3.0000000000) {
													square(size = [7.0000000000, 7.0000000000]);
												}
											}
											translate(v = [4.0000000000, 4.0000000000, 0]) {
												circle(r = 0.7500000000);
											}
										}
									}
									mirror(v = [1, 0, 0]) {
										translate(v = [-60.0000000000, -33.0000000000, 0]) {
											difference() {
												translate(v = [-1.5000000000, -1.5000000000, 0]) {
													offset(r = 3.0000000000) {
														square(size = [7.0000000000, 7.0000000000]);
													}
												}
												translate(v = [4.0000000000, 4.0000000000, 0]) {
													circle(r = 0.7500000000);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		translate(v = [48.2000000000, 0, 8.2500000000]) {
			cube(center = true, size = [1.6000000000, 66, 16.5000000000]);
		}
		translate(v = [39.9000000000, 0, 8.2500000000]) {
			cube(center = true, size = [1.6000000000, 66, 16.5000000000]);
		}
		translate(v = [-52, 1, 5.9999500000]) {
			cube(center = true, size = [14, 1.6000000000, 11.9999000000]);
		}
		translate(v = [-45, 0, 5.9998500000]) {
			cube(center = true, size = [1.6000000000, 66, 11.9999000000]);
		}
		translate(v = [33, 0, 5.9998500000]) {
			cube(center = true, size = [1.6000000000, 66, 11.9999000000]);
		}
		translate(v = [-42.2500000000, 1, -0.0001000000]) {
			cylinder(h = 9, r = 5);
		}
		translate(v = [30.2500000000, 1, -0.0001000000]) {
			cylinder(h = 9, r = 5);
		}
	}
	#union() {
		translate(v = [60.0000000000, 0, 14]) {
			rotate(a = [0, 0, 90]) {
				union() {
					translate(v = [0, 3, 0]) {
						rotate(a = [90, 0, 0]) {
							linear_extrude(height = 3) {
								offset(r = 3) {
									square(center = true, size = [42, 14]);
								}
							}
						}
					}
					translate(v = [-26.5000000000, 3, -12.5000000000]) {
						cube(size = [53, 2, 25]);
					}
					translate(v = [-26.0000000000, 5, -10.5000000000]) {
						cube(size = [52, 14.3000000000, 21]);
					}
					translate(v = [26.0000000000, 19, 0]) {
						rotate(a = [0, 90, 0]) {
							linear_extrude(height = 20) {
								offset(r = 3) {
									square(center = true, size = [8, 4]);
								}
							}
						}
					}
					translate(v = [13, 25, -3]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [13, 25, -2]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [13, 25, -1]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [13, 25, 0]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [13, 25, 1]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [13, 25, 2]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, -3]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, -2]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, -1]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, 0]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, 1]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
					translate(v = [-9, 25, 2]) {
						#rotate(a = [90, 0, 0]) {
							cylinder(d = 5, h = 10);
						}
					}
				}
			}
		}
		translate(v = [-6, 0, 9]) {
			union() {
				translate(v = [0, -1.7500000000, -0.8000000000]) {
					union() {
						cube(center = true, size = [90.0000000000, 53.5000000000, 1.6000000000]);
						translate(v = [0, 0, 2.3000000000]) {
							cube(center = true, size = [90.0000000000, 53.5000000000, 3]);
						}
						translate(v = [-36.2500000000, 3, -3]) {
							cylinder(center = true, d = 2, h = 5);
						}
						translate(v = [36.2500000000, 3, -3]) {
							cylinder(center = true, d = 2, h = 5);
						}
					}
				}
				translate(v = [0, 17.5000000000, 3.7500000000]) {
					cube(center = true, size = [15, 35, 7.5000000000]);
				}
				union() {
					translate(v = [-28.0000000000, -17.5000000000, 6.2500000000]) {
						cube(center = true, size = [13, 35, 12.5000000000]);
					}
					translate(v = [-9.3333333333, -17.5000000000, 6.2500000000]) {
						cube(center = true, size = [13, 35, 12.5000000000]);
					}
					translate(v = [9.3333333333, -17.5000000000, 6.2500000000]) {
						cube(center = true, size = [13, 35, 12.5000000000]);
					}
					translate(v = [28.0000000000, -17.5000000000, 6.2500000000]) {
						cube(center = true, size = [13, 35, 12.5000000000]);
					}
				}
			}
		}
	}
}
/***********************************************
*********      SolidPython code:      **********
************************************************
 
from dataclasses import dataclass
from solid import *
from solid.utils import *

import library_box
import library_pcb
import library_display

SMALL = 0.0001


@dataclass
class UsbSwitchBoxCores:
    size_x: float
    core_pcb_assembled = library_pcb.CorePcbAssembled()
    pcb_offset_x = -6
    pcb_offset_z = 9
    is_top: bool

    @property
    def core_pcb(self):
        return self.core_pcb_assembled.core_pcb

    def draw(self):
        cores = union()
        # Display
        display_x = self.size_x / 2
        display_z = 14
        cores += translate(v=[display_x, 0, display_z])(
            rotate([0, 0, 90])(library_display.CoreDisplay(is_top=self.is_top).draw())
        )
        # PCB
        cores += translate(v=[self.pcb_offset_x, 0, self.pcb_offset_z])(
            self.core_pcb_assembled.draw()
        )
        return debug(cores)


@dataclass
class SupportY:
    size_y: float
    size_z: float
    thickness_x = 1.6

    def draw(self):
        return cube(
            size=[
                self.thickness_x,
                self.size_y,
                self.size_z,
            ],
            center=True,
        )


@dataclass
class SupportX:
    size_x: float
    size_z: float
    thickness_y = 1.6

    def draw(self):
        return cube(
            size=[
                self.size_x,
                self.thickness_y,
                self.size_z,
            ],
            center=True,
        )


@dataclass
class UsbSwitchBoxBottom:
    size_y = 66
    size_x = 120
    size_z = 16.5
    hull_thickness = 1.6
    corner_r = 2.5
    screw_hole_bottom_d = 1.5
    screw_hole_top_d = 2.5
    is_top: bool

    def draw(self):
        usb_switch_box_cores = UsbSwitchBoxCores(size_x=self.size_x, is_top=self.is_top)

        pcb_offset_x = usb_switch_box_cores.pcb_offset_x
        pcb_offset_z = usb_switch_box_cores.pcb_offset_z
        screws_distance_x = usb_switch_box_cores.core_pcb.screws_distance_x
        screws_distance_y = usb_switch_box_cores.core_pcb.screws_distance_y
        pcp_support_z_over = usb_switch_box_cores.core_pcb.pcp_support_z_over

        # Box with corners
        corner = library_box.Corner(hole_d=self.screw_hole_bottom_d)
        boxskeleton = library_box.BoxSkeleton(
            size_x=self.size_x,
            size_y=self.size_y,
            size_z=self.size_z,
            hull_thickness=self.hull_thickness,
        )
        box = library_box.Box(boxskeleton=boxskeleton, corner=corner)

        # Box with supports
        box_complete = union()
        box_complete += box.draw()
        support = SupportY(size_y=self.size_y, size_z=self.size_z)

        display_supports_x = (11.0, 19.3)
        for x in display_supports_x:
            box_complete += (
                translate(
                    v=[
                        self.size_x / 2 - x - support.thickness_x / 2,
                        0,
                        support.size_z / 2,
                    ]
                )(support.draw()),
            )

        if True:
            pcb_support_x = SupportX(
                size_x=14, size_z=pcb_offset_z + pcp_support_z_over - SMALL
            )
            box_complete += translate(
                [-52, screws_distance_y, pcb_support_x.size_z / 2]
            )(pcb_support_x.draw())

        if True:
            pcb_support_y = SupportY(
                size_y=self.size_y, size_z=pcb_offset_z + pcp_support_z_over - SMALL
            )
            for x in (pcb_offset_x - 39, pcb_offset_x + 39):
                box_complete += (
                    translate(
                        v=[
                            x,
                            0,
                            pcb_support_y.size_z / 2 - SMALL,
                        ]
                    )(pcb_support_y.draw()),
                )

        if True:
            pcb_screws_x = (
                pcb_offset_x - screws_distance_x / 2,
                pcb_offset_x + screws_distance_x / 2,
            )
            for x in pcb_screws_x:
                box_complete += (
                    translate(
                        v=[
                            x,
                            screws_distance_y,
                            -SMALL,
                        ]
                    )(cylinder(h=pcb_offset_z, r=5)),
                )

        return box_complete - usb_switch_box_cores.draw()


SEGMENTS = 100

box = UsbSwitchBoxBottom(is_top=False)

scad_render_to_file(
    box.draw(), file_header=f"$fn = {SEGMENTS};", include_orig_code=True
)
 
 
************************************************/
